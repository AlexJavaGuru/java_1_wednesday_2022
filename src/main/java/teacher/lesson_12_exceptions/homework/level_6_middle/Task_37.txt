Дизайн решения мы придумали.

Теперь пришло время ... написать тесты (acceptance tests)! :)

Почему бы и нет? Давайте попробуем воспользоваться такой техникой
как TDD - Test Driven Design. Напиши тесты сначала, а потом пиши сам код.

Создайте класс ProductValidatorImpl implements ProductValidator {

    List<ValidationException> validate(Product product) {
        return null; // просто что бы код компилировался
    }

}

Создайте класс ProductValidatorImplTest и напишите тесты на все требования
(все тесты будут фейлиться - это нормально, у нас же нет имплементации):

К названию продукта выдвигаются следующие требования:
- не должно быть пустым
- не должно быть короче 3 символов
- не должно быть длиннее 100 символов
- должно содержать только английские буквы и цифры, другие символы не допустимы

К цене продукта выдвигаются следующие требования:
- не должна быть пустой
- должна содержать только цифры
- не может быть 0

К описанию продукта выдвигаются следующие требования:
- не должно быть длиннее 2000 символов
- должно содержать только английские буквы и цифры, другие символы не допустимы

При написании тестов перед написанием кода заставляет вас думать о самом
бизнес требовании, а не о его реализации в коде. Это две разне вещи!
Если нет кода, то при написании теста вы пользуетесь только выбвинутыми
требованиями. Ваши тесты будут отображать/фиксировать требования, которым
должно удовлетворять ваше решение. Это и есть acceptance tests! Самые лучшие
тесты, которые только возможны. Тесты фиксирующие бизнес требования к вашему
программному обеспечению.

Напишите тесты на все требования указанные выше!

Дайте каждому правилу своё название, например: Rule_1, Rule_2, etc.
Оно вам потребуется, так как объект ValidationException должен содержать
название правила.